<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Globe Visualization</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: Arial; }
        #globeViz { width: 100vw; height: 100vh; cursor: grab; }
        #globeViz:active { cursor: grabbing; }
        #info { 
            position: absolute; top: 20px; left: 20px; 
            color: white; background: rgba(0,0,0,0.7); 
            padding: 15px; border-radius: 5px; z-index: 100;
        }
        .controls { 
            position: absolute; bottom: 20px; left: 20px; 
            color: white; background: rgba(0,0,0,0.7); 
            padding: 10px; border-radius: 5px; font-size: 12px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
</head>

<body>
    <div id="globeViz"></div>

    <script>
        
        const world = new Globe(document.getElementById('globeViz'))
            .globeImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-dark.jpg')
            .pointOfView({ altitude: 3 }, 5000)
            .polygonCapColor(f => 'rgba(200, 0, 0, 0.6)')
            .polygonSideColor(() => 'rgba(255, 0, 0, 0.05)')
            .polygonStrokeColor(() => '#111');

        // Load both CSV and GeoJSON
        Promise.all([
            fetch('datasets/deaths-in-armed-conflicts-based-on-where-they-occurred.csv').then(res => res.text()),
            fetch('datasets/ne_110m_admin_0_countries.geojson').then(res => res.json())
        ]).then(([csvText, countries]) => {

            // --- Parse CSV ---
            const rows = csvText.trim().split('\n').slice(1).map(line => {
                const [Entity, Year, Best, Low, High] = line.split(',');
                return { Entity, Year: +Year, Best: +Best, Low: +Low, High: +High };
            });

            // Helper: get all records for a name
            function get_deaths_by_name(name) {
                const filtered = rows.filter(r => r.Entity.toLowerCase() === name.toLowerCase());
                if (filtered.length === 0) return null;
                return filtered;
            }

            // Compute latest year values
            const latestYear = Math.max(...rows.map(r => r.Year));
            const latestData = Object.fromEntries(
                rows.filter(r => r.Year === latestYear).map(r => [r.Entity.toLowerCase(), r])
            );


            console.log('CSV rows:', rows.length);
            console.log('GeoJSON features:', countries.features.length);

            // --- Filter and enrich GeoJSON ---
            const features = countries.features.filter(f => f.properties.ISO_A2 !== 'AQ');

            features.forEach(f => {
                const entity = f.properties.ADMIN.toLowerCase();
                f.properties.deaths = latestData[entity]?.Best ?? 0;
            });

            // --- Update globe polygons ---
            world.polygonsData(features)
                .polygonLabel(({ properties: d }) => `
                <b>${d.ADMIN} (${d.ISO_A2})</b><br/>
                Deaths (latest year ${latestYear}): <b>${d.deaths}</b>
            `);

            function makeRagdollMesh() {
                const group = new THREE.Group();

                const material = new THREE.MeshStandardMaterial({ color: 0xff5555, roughness: 0.7 });
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.02), material);
                head.position.y = 0.06;
                group.add(head);

                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.05, 8), material);
                group.add(body);

                const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.04, 8), material);
                leftLeg.position.set(-0.01, -0.045, 0);
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.04, 8), material);
                rightLeg.position.set(0.01, -0.045, 0);
                group.add(rightLeg);

                return group;
            }
            
            const maxDeaths = Math.max(...features.map(f => f.properties.deaths || 0));
            const minDeaths = 0;

            function interpolateColor(color1, color2, factor) {

            }
            
            function spawnRagdollsAt(center) {
                const ragdolls = Array.from({ length: 5 }, () => ({
                    lat: center.lat + (Math.random() - 0.5) * 0.3,
                    lng: center.lng + (Math.random() - 0.5) * 0.3
                }));

                world.customLayerData(ragdolls)
                    .customThreeObject(makeRagdollMesh)
                    .customThreeObjectUpdate((obj, d) => {
                        const { x, y, z } = world.getCoords(d);
                        obj.position.set(x, y, z);
                    });
            }

            let zoomedCountry = null; // store the currently zoomed-in country

            world.onPolygonClick(f => {
                const centroid = getPolygonCentroid(f);
                if (!centroid) return;

                const countryName = f.properties.ADMIN;

                if (zoomedCountry === countryName) {
                    // Clicking the same country → zoom out to global view
                    world.pointOfView({ lat: 0, lng: 0, altitude: 3 }, 1500);
                    zoomedCountry = null;

                    // Optional: remove ragdolls when zooming out
                    world.customLayerData([]);
                } else {
                    // Clicking a new country → zoom in
                    world.pointOfView({ lat: centroid.lat, lng: centroid.lng, altitude: 0.7 }, 1500);
                    zoomedCountry = countryName;

                    // Spawn ragdolls at the country
                    spawnRagdollsAt(centroid);
                }
            });
            

            function getPolygonCentroid(feature) {
                try {
                    // For simple polygons (most countries)
                    const coords = feature.geometry.coordinates[0];
                    if (!coords || !coords.length) return null;

                    let lonSum = 0, latSum = 0;
                    for (const [lon, lat] of coords) {
                        lonSum += lon;
                        latSum += lat;
                    }
                    const n = coords.length;
                    return { lat: latSum / n, lng: lonSum / n };

                } catch (e) {
                    console.warn("Failed to compute centroid", e);
                    return null;
                }
            }
              
        });
    </script>
</body>
  